#include <Arduino.h>
#include <lvgl/lvgl.h>

#include "Config.h"
#include "PreferencesManager.h"
#include "PullStateManager.h"
#include "ScreenUpdater.h"
#include "SpeedModule.h"
#include "StateManager.h"
#include "dev_utils/benchmark.h"
#include "display/backlight.h"
#include "display/display.h"
#include "touch/calibration.h"
#include "touch/touch.h"

#ifdef DEVELOPMENT_MODE
#include "dev_utils/DevSimulator.h"
#endif

// UI generated by Squareline
#include "../ui/ui.h"

// LVGL buffers and drivers
static lv_disp_draw_buf_t draw_buf;
static lv_color_t buf1[800 * 40];
static lv_disp_drv_t disp_drv;
static lv_indev_drv_t indev_drv;

//========================================================================
// LVGL Callbacks
//========================================================================

// Display flushing callback for LVGL
void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) {
  uint32_t w = (area->x2 - area->x1 + 1);
  uint32_t h = (area->y2 - area->y1 + 1);

  lcd.startWrite();
  lcd.setAddrWindow(area->x1, area->y1, w, h);
  lcd.pushPixels((uint16_t *)color_p, w * h);
  lcd.endWrite();

  lv_disp_flush_ready(disp);
}

// Touchpad reading callback for LVGL
void my_touchpad_read(lv_indev_drv_t *indev_drv, lv_indev_data_t *data) {
  uint16_t touchX, touchY, touchZ;
  bool touched = touch.readTouchPoint(&touchX, &touchY, &touchZ);

  if (touched) {
    data->state = LV_INDEV_STATE_PR;
    data->point.x = touchX;
    data->point.y = touchY;
  } else {
    data->state = LV_INDEV_STATE_REL;
  }
}

//========================================================================
// Core System Functions
//========================================================================

// LVGL task handler
void lvgl_task(void *parameter) {
  while (1) {
    lv_timer_handler();
    delay(5);
  }
}

// Initialize the display and touch
void init_display_and_touch() {
  // Initialize backlight
  ledcSetup(LCD_BL_CHANNEL, LCD_BL_FREQ, LCD_BL_RESOLUTION);
  ledcAttachPin(LCD_BL_PIN, LCD_BL_CHANNEL);
  setBacklight(0);  // Start with backlight off

  // Initialize display
  if (!lcd.begin()) {
    Serial.println("Display initialization failed!");
    while (1) delay(100);
  }

  // Configure display
  lcd.setRotation(0);  // Note: This will be adjusted based on Squareline Studio settings
  setBacklight(192);   // Set to ~75% brightness

  // Initialize touch
  if (!touch.begin()) {
    Serial.println("Touch initialization failed!");
    while (1) delay(100);
  }

  // Load touch calibration data
  bool calibration_loaded = touch.loadCalibration();
  bool recalibration_needed = touch.checkRecalibrationFlag();

  // Perform calibration if needed
  if (!calibration_loaded || recalibration_needed) {
    Serial.println("Touch calibration required...");
    // Run the calibration
    bool cal_success = TouchCalibration::runCalibration(lcd, touch);
    if (cal_success) {
      Serial.println("Calibration successful");
      touch.clearRecalibrationFlag();
    } else {
      Serial.println("Calibration failed!");
    }
  } else {
    Serial.println("Touch calibration loaded successfully");
  }
}

// Initialize LVGL
void init_lvgl() {
  lv_init();

  // Initialize display buffer
  // lv_disp_draw_buf_init(&draw_buf, buf1, NULL, 800 * 10);
  lv_disp_draw_buf_init(&draw_buf, buf1, NULL, 800 * 40);

  // Initialize display driver
  lv_disp_drv_init(&disp_drv);
  disp_drv.flush_cb = my_disp_flush;
  disp_drv.draw_buf = &draw_buf;
  disp_drv.hor_res = 800;
  disp_drv.ver_res = 480;
  lv_disp_drv_register(&disp_drv);

  // Initialize input device driver
  lv_indev_drv_init(&indev_drv);
  indev_drv.type = LV_INDEV_TYPE_POINTER;
  indev_drv.read_cb = my_touchpad_read;
  lv_indev_drv_register(&indev_drv);
}

//========================================================================
// Arduino Main Functions
//========================================================================

void setup() {
  Serial.begin(115200);
  delay(1000);

  StateManager::loadPreferences();

  Serial.println("Starting M4 7-inch RGB Display UI: M4_MCU_2025...");
  Serial.print("Version: ");
  Serial.println(VERSION);
  Serial.print("Build Date: ");
  Serial.println(__DATE__ " " __TIME__);

  init_display_and_touch();
  init_lvgl();
  ui_init();
  PullStateManager::init();
  SpeedModule::begin();

  xTaskCreatePinnedToCore(lvgl_task, "lvgl_task", 4096, NULL, 1, NULL, 1);
  Serial.println("Setup complete");
}

bool isMainScreenReady() {
  return uic_MainLabelSpeedValue && uic_MainLabelDistanceValue && uic_MainLabelTachValue && uic_MainLabelDriverName &&
         uic_MainLabelDriverNumber && uic_MainLabelClassName;
}

unsigned long lastScreenUpdate = 0;

void loop() {
  lv_timer_handler();
  updateBacklight();
  benchmark_update();
  PullStateManager::update();

#ifdef DEVELOPMENT_MODE
  devSimulator::update();
#endif

  unsigned long now = millis();
  if (isMainScreenReady() && now - lastScreenUpdate >= SCREEN_UPDATE_INTERVAL_MS) {
    lastScreenUpdate = now;
    updateMainScreen();
  }

  delay(5);
}