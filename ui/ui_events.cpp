// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.1
// LVGL version: 8.3.11
// Project name: M4_MCU_2025

#include <algorithm>
#include <vector>

#include "Config.h"
#include "PullStateManager.h"
#include "SpeedModule.h"
#include "StateManager.h"
#include "custom_ui/custom_keyboard.h"
#include "dev_utils/benchmark.h"
#include "display/backlight.h"
#include "touch/touch.h"
#include "ui.h"

const char *VERSION_STRING = VERSION;
const char *BUILD_DATETIME = __DATE__ " " __TIME__;

inline void setObjectVisible(lv_obj_t *obj, bool visible) {
  if (visible) {
    lv_obj_clear_flag(obj, LV_OBJ_FLAG_HIDDEN);
  } else {
    lv_obj_add_flag(obj, LV_OBJ_FLAG_HIDDEN);
  }
}

void applyMainScreenPreferences() {
  // Set the visibility of the main screen elements based on preferences
  setObjectVisible(uic_MainContainerTach, StateManager::prefs().tachEnabled);
  setObjectVisible(uic_MainContainerRelays, StateManager::prefs().relaysEnabled);
  setObjectVisible(uic_MainContainerLimit, StateManager::prefs().limitSwitchesEnabled);
  benchmark_set_enabled(StateManager::prefs().benchmarkMode);

  setBacklight(StateManager::prefs().screenBrightness);
}

void loadMainScreen(lv_event_t *e) {
  applyMainScreenPreferences();
  float distance = StateManager::getDistance();
  float speed = StateManager::getSpeed();
  float trackLength = StateManager::getTrackLength();
  bool isMetric = (StateManager::prefs().unitSystem == UnitSystem::METRIC);

  // Distance Bar
  lv_bar_set_range(uic_MainBarDistanceProgress, 0, (int)trackLength);
  lv_bar_set_value(uic_MainBarDistanceProgress, (int)distance, LV_ANIM_OFF);

  // Distance Label + Unit
  if (isnan(distance) || distance <= 0) {
    lv_label_set_text(uic_MainLabelDistanceValue, "---.--");
  } else {
    lv_label_set_text_fmt(uic_MainLabelDistanceValue, "%.2f", distance);
  }
  lv_label_set_text(uic_MainLabelDistanceUnit, isMetric ? "m" : "ft");

  // Speed Label + Unit
  if (isnan(speed) || speed <= 0) {
    lv_label_set_text(uic_MainLabelSpeedValue, "--.-");
  } else {
    lv_label_set_text_fmt(uic_MainLabelSpeedValue, "%.1f", speed);
  }
  lv_label_set_text(uic_MainLabelSpeedUnit, isMetric ? "km/h" : "mph");

  // Tach Label + Unit
  float rpm = StateManager::state().rpm;
  if (isnan(rpm) || rpm <= 0) {
    lv_label_set_text(uic_MainLabelTachValue, "---");
  } else {
    lv_label_set_text_fmt(uic_MainLabelTachValue, "%.0f", rpm);
  }
  lv_label_set_text(uic_MainLabelTachUnit, "RPM");

  // Class Info
  lv_label_set_text_fmt(uic_MainLabelClassName, "%s", StateManager::prefs().pullingClassName.c_str());

  // Driver Info
  lv_label_set_text_fmt(uic_MainLabelDriverNumber, "#%d", StateManager::prefs().driverNumber);
  lv_label_set_text(uic_MainLabelDriverName, StateManager::prefs().driverName.c_str());
}

void SettingsSwitchUnitsChange(lv_event_t *e) {
  lv_obj_t *switchObj = lv_event_get_target(e);
  bool isMetric = lv_obj_has_state(switchObj, LV_STATE_CHECKED);

  // Set unit system based on switch state
  StateManager::setUnitSystem(isMetric ? UnitSystem::METRIC : UnitSystem::IMPERIAL);

  // Update label text
  if (ui_SettingsLabelTrackLengthUnitsTitle != nullptr) {
    lv_label_set_text(ui_SettingsLabelTrackLengthUnitsTitle, isMetric ? "Meters" : "Feet");
  }
}

void SettingsSwitchBenchmarkChange(lv_event_t *e) {
  lv_obj_t *cb = lv_event_get_target(e);
  bool enabled = lv_obj_get_state(cb) & LV_STATE_CHECKED;
  benchmark_set_enabled(enabled);

  StateManager::prefs().benchmarkMode = lv_obj_has_state(uic_SettingsSwitchBenchmarkToggle, LV_STATE_CHECKED);
  StateManager::savePreferences();
}

void SettingsSliderBrightnessChange(lv_event_t *e) {
  lv_obj_t *slider = lv_event_get_target(e);
  uint8_t brightness = (uint8_t)lv_slider_get_value(slider);

  // Get event code
  lv_event_code_t code = lv_event_get_code(e);

  // Update label immediately
  lv_label_set_text_fmt(ui_SettingsLabelBrightness, "%d%%", (brightness * 100) / 255);

  // For immediate visual feedback during slider movement
  setBacklightFast(brightness);

  // Update preference value
  StateManager::prefs().screenBrightness = brightness;

  // Only save preferences when slider is released to avoid writing to flash constantly
  if (code == LV_EVENT_RELEASED) {
    // Only save to flash when the user releases the slider
    StateManager::savePreferences();
  }
}

void SettingsTrackLengthText(lv_event_t *e) {
  const char *text = lv_textarea_get_text(uic_SettingsTextareaTrackLengthText);
  float val = atof(text);
  if (val > 0.0f) {
    StateManager::prefs().trackLengthFeet = val;
    StateManager::savePreferences();
  }
}

void SettingsSwitchTachChange(lv_event_t *e) {
  StateManager::prefs().tachEnabled = lv_obj_has_state(uic_SettingsSwitchTachToggle, LV_STATE_CHECKED);
  StateManager::savePreferences();
}

void SettingsSwitchLimitChange(lv_event_t *e) {
  StateManager::prefs().limitSwitchesEnabled = lv_obj_has_state(uic_SettingsSwitchLimitToggle, LV_STATE_CHECKED);
  StateManager::savePreferences();
}

void SettingsSwitchRelaysChange(lv_event_t *e) {
  StateManager::prefs().relaysEnabled = lv_obj_has_state(uic_SettingsSwitchRelaysToggle, LV_STATE_CHECKED);
  StateManager::savePreferences();
}

static void exit_tab_handler(lv_event_t *e) {
  lv_obj_t *btnmatrix = lv_event_get_current_target(e);
  lv_obj_t *tabview = (lv_obj_t *)lv_event_get_user_data(e);

  int selected_idx = lv_btnmatrix_get_selected_btn(btnmatrix);

  if (selected_idx == 8) {  // Exit tab is the 8th tab (index 7)
    printf("Exit tab clicked\n");

    lv_tabview_set_act(tabview, 0, LV_ANIM_OFF);  // Reset tab to first
    lv_scr_load(ui_ScreenMain);                   // Go back to main screen
    lv_event_stop_processing(e);                  // Prevent tab switch
  }
}

void SettingsScreenLoaded(lv_event_t *e) {
  // General Settings
  lv_event_code_t code = lv_event_get_code(e);
  if (code == LV_EVENT_SCREEN_LOADED) {
    setup_custom_number_keyboard(ui_SettingsKeyboardSettingsNumberKeyboard);

    // Set units toggle to match current preference
    (StateManager::getUnitSystem() == UnitSystem::METRIC)
        ? lv_obj_add_state(ui_SettingsSwitchUnitsToggle, LV_STATE_CHECKED)
        : lv_obj_clear_state(ui_SettingsSwitchUnitsToggle, LV_STATE_CHECKED);
    // Toggle switches
    StateManager::prefs().benchmarkMode ? lv_obj_add_state(uic_SettingsSwitchBenchmarkToggle, LV_STATE_CHECKED)
                                        : lv_obj_clear_state(uic_SettingsSwitchBenchmarkToggle, LV_STATE_CHECKED);

    StateManager::prefs().tachEnabled ? lv_obj_add_state(uic_SettingsSwitchTachToggle, LV_STATE_CHECKED)
                                      : lv_obj_clear_state(uic_SettingsSwitchTachToggle, LV_STATE_CHECKED);

    StateManager::prefs().limitSwitchesEnabled ? lv_obj_add_state(uic_SettingsSwitchLimitToggle, LV_STATE_CHECKED)
                                               : lv_obj_clear_state(uic_SettingsSwitchLimitToggle, LV_STATE_CHECKED);

    StateManager::prefs().relaysEnabled ? lv_obj_add_state(uic_SettingsSwitchRelaysToggle, LV_STATE_CHECKED)
                                        : lv_obj_clear_state(uic_SettingsSwitchRelaysToggle, LV_STATE_CHECKED);

    // Brightness
    lv_slider_set_value(uic_SettingsSliderBrightnessSlider, StateManager::prefs().screenBrightness, LV_ANIM_OFF);

    // Track length
    char buf[16];
    snprintf(buf, sizeof(buf), "%.1f", StateManager::prefs().trackLengthFeet);
    lv_textarea_set_text(uic_SettingsTextareaTrackLengthText, buf);
  }

  // Speed and Distance Page
  // Update calibration number input box with stored integer pulse calibration value
  char calibBuf[16];
  snprintf(calibBuf, sizeof(calibBuf), "%d", StateManager::getSpeedCalibrationNumber());
  lv_textarea_set_text(ui_SettingsTextareaCalibrationNumberTextArea, calibBuf);

  // About Page
  lv_label_set_text(ui_SettingsLabelVersionData, VERSION_STRING);
  lv_label_set_text(ui_SettingsLabelBuildDateData, BUILD_DATETIME);

  // Exit Page
  lv_obj_t *btnmatrix = lv_tabview_get_tab_btns(ui_SettingsTabviewSettingsView);
  lv_obj_add_event_cb(btnmatrix, exit_tab_handler, LV_EVENT_VALUE_CHANGED, ui_SettingsTabviewSettingsView);
}

void READYStageBtnPressed(lv_event_t *e) { PullStateManager::handleStagePressed(); }

void STAGEDCancelBtnPressed(lv_event_t *e) { PullStateManager::handleCancelPressed(); }

void PULLINGStopBtnPressed(lv_event_t *e) { PullStateManager::handleStopPressed(); }

void PULLENDDiscardBtnPressed(lv_event_t *e) { PullStateManager::handleDiscardPressed(); }

void PULLENDSaveBtnPressed(lv_event_t *e) { PullStateManager::handleSavePressed(); }

void EMERGENCYSTOPResetBtnPressed(lv_event_t *e) { PullStateManager::handleResetPressed(); }

void CloseMsgBoxEventHandler(lv_event_t *e) {
  lv_obj_t *mbox = lv_event_get_current_target(e);

  // Optional: log or check which button was pressed
  const char *btn_txt = lv_msgbox_get_active_btn_text(mbox);
  LV_LOG_USER("MsgBox button pressed: %s", btn_txt);

  // Close the message box
  if (strcmp(btn_txt, "OK") == 0) {
    lv_msgbox_close(mbox);
  }
  if (strcmp(btn_txt, "Close") == 0) {
    lv_msgbox_close(mbox);
  }
}

void EnableTachHelpButtonPressed(lv_event_t *e) {
  // Define the button options
  static const char *btn_txts[] = {"OK", NULL};

  // Help text
  const char *help_text =
      "Enabling this option allows access to the Tach settings screen.\n"
      "The tachometer will appear on the main run screen, and the system will attempt "
      "to connect to the tractor's Tach Smart Sensor to monitor engine RPM.\n\n"
      "If you're not tracking RPM during pulls, you can safely disable this feature "
      "to remove it from the main screen.";

  // Create a modal message box
  lv_obj_t *mbox = lv_msgbox_create(NULL, "ENABLE TACHOMETER", help_text, btn_txts, true);

  // Center the message box on the screen
  lv_obj_set_width(mbox, 600);  // Adjust the width here
  lv_obj_center(mbox);

  // Attach the close handler to the message box
  lv_obj_add_event_cb(mbox, CloseMsgBoxEventHandler, LV_EVENT_VALUE_CHANGED, NULL);
}

void EnableLimitsHelpButtonPressed(lv_event_t *e) {
  // Define the button options
  static const char *btn_txts[] = {"OK", NULL};

  // Help text
  const char *help_text =
      "Enabling this option allows you to monitor and respond to two external limit switches.\n"
      "The limit switch status will be displayed on the main run screen.\n\n"
      "Limit switches can be tied to alarms or pull state conditions, "
      "making it possible to trigger events when a mechanical switch is engaged or released.";

  // Create a modal message box
  lv_obj_t *mbox = lv_msgbox_create(NULL, "ENABLE LIMIT SWITCHES", help_text, btn_txts, true);

  // Center the message box on the screen
  lv_obj_set_width(mbox, 600);  // Adjust the width here
  lv_obj_center(mbox);

  // Attach the close handler to the message box
  lv_obj_add_event_cb(mbox, CloseMsgBoxEventHandler, LV_EVENT_VALUE_CHANGED, NULL);
}

void EnableRelayHelpButtonPressed(lv_event_t *e) {
  // Define the button options
  static const char *btn_txts[] = {"OK", NULL};

  // Help text
  const char *help_text =
      "Enabling this option allows you to set up and configure relays.\n"
      "You'll be able to view the current relay status on the main run screen and define "
      "custom behavior for each relay.\n\n"
      "Relays can be triggered based on alarm thresholds or changes in pull state, "
      "allowing flexible control over external devices such as lights, indicators, "
      "horns, or mechanical actions to modify the behavior of the sled.";

  // Create a modal message box
  lv_obj_t *mbox = lv_msgbox_create(NULL, "ENABLE RELAYS", help_text, btn_txts, true);

  // Center the message box on the screen
  lv_obj_set_width(mbox, 600);  // Adjust the width here
  lv_obj_center(mbox);

  // Attach the close handler to the message box
  lv_obj_add_event_cb(mbox, CloseMsgBoxEventHandler, LV_EVENT_VALUE_CHANGED, NULL);
}

void SettingsSwitchHelpIconVisibility(lv_event_t *e) {
  // Your code here
}

void HELPCalNumber(lv_event_t *e) {
  // Define the button options
  static const char *btn_txts[] = {"OK", NULL};

  // Help text
  const char *help_text =
      "The calibration number represents how many sensor pulses occur during a 300-foot pull.\n"
      "This number is used to convert pulses into accurate speed and distance measurements.\n\n"
      "You can manually enter this number, or use one of the tools below to calculate it "
      "automatically based on your gear and wheel setup, by driving off 300 feet, "
      "or by selecting a standard radar or GPS calibration value.";

  // Create a modal message box
  lv_obj_t *mbox = lv_msgbox_create(NULL, "CALIBRATION NUMBER", help_text, btn_txts, true);

  // Center the message box on the screen
  lv_obj_set_width(mbox, 600);  // Adjust the width here
  lv_obj_center(mbox);

  // Attach the close handler to the message box
  lv_obj_add_event_cb(mbox, CloseMsgBoxEventHandler, LV_EVENT_VALUE_CHANGED, NULL);
}

void HELPGearToothCalc(lv_event_t *e) {
  // Define the button options
  static const char *btn_txts[] = {"OK", NULL};

  // Help text
  const char *help_text =
      "This calculator estimates your calibration number based on your hardware setup.\n\n"
      "- Enter the number of teeth on your sprocket (not the number of gears).\n"
      "- Enter the diameter of the drive wheel in inches.\n"
      "- Enter the gear ratio between the wheel and the sensor (use 1.00 for direct drive).\n\n"
      "The system will calculate how many pulses would occur in a 300-foot pull.\n"
      "You can still fine-tune this value afterward using the manual input or drive-off calibration.";

  // Create a modal message box
  lv_obj_t *mbox = lv_msgbox_create(NULL, "GEAR TOOTH CALCULATOR", help_text, btn_txts, true);

  // Center the message box on the screen
  lv_obj_set_width(mbox, 600);  // Adjust the width here
  lv_obj_center(mbox);

  // Attach the close handler to the message box
  lv_obj_add_event_cb(mbox, CloseMsgBoxEventHandler, LV_EVENT_VALUE_CHANGED, NULL);
}

void HELPAutoCal(lv_event_t *e) {
  // Define the button options
  static const char *btn_txts[] = {"OK", NULL};

  // Help text
  const char *help_text =
      "This option lets you calibrate your speed input by driving exactly 300 feet.\n"
      "Press 'Start Driving' to begin counting pulses, then drive straight down the track.\n"
      "Press 'Finished Driving' when you've reached the 300-foot mark.\n\n"
      "The system will count the total number of pulses during that distance "
      "and automatically save that number as your calibration value.\n\n"
      "If you are using metric units, drive exactly 91.44 meters instead.";

  // Create a modal message box
  lv_obj_t *mbox = lv_msgbox_create(NULL, "AUTO CALIBRATION", help_text, btn_txts, true);

  // Center the message box on the screen
  lv_obj_set_width(mbox, 600);  // Adjust the width here
  lv_obj_center(mbox);

  // Attach the close handler to the message box
  lv_obj_add_event_cb(mbox, CloseMsgBoxEventHandler, LV_EVENT_VALUE_CHANGED, NULL);
}

void HELPPresetCalNumber(lv_event_t *e) {
  // Define the button options
  static const char *btn_txts[] = {"OK", NULL};

  // Help text
  const char *help_text =
      "If you're using a radar or GPS-based speed sensor, you can use this button to apply "
      "a standard factory calibration number.\n\n"
      "This skips the need to manually calculate or drive off 300 feet.\n"
      "However, if you want to fine-tune the calibration for your specific setup, "
      "you can still use the drive-off method or manually enter your own value.";

  // Create a modal message box
  lv_obj_t *mbox = lv_msgbox_create(NULL, "CALIBRATION PRESETS", help_text, btn_txts, true);

  // Center the message box on the screen
  lv_obj_set_width(mbox, 600);  // Adjust the width here
  lv_obj_center(mbox);

  // Attach the close handler to the message box
  lv_obj_add_event_cb(mbox, CloseMsgBoxEventHandler, LV_EVENT_VALUE_CHANGED, NULL);
}

void SaveCalibrationNumberButton(lv_event_t *e) {
  int val = atoi(lv_textarea_get_text(ui_SettingsTextareaCalibrationNumberTextArea));
  SpeedModule::saveManualCalibration(val);
}

void SaveCalibrationCalculatorNumberButton(lv_event_t *e) { SpeedModule::saveCalculatorCalibration(); }

void StartAutoDriveButtonPressed(lv_event_t *e) { SpeedModule::startDriveOffCalibration(); }

void SaveCalibrationAutoDriveNumberButton(lv_event_t *e) { SpeedModule::stopDriveOffCalibration(); }

void SaveRadarCalibration(lv_event_t *e) { SpeedModule::applyRadarCalibration(); }

void FinishAutoDriveButtonPressed(lv_event_t *e) { SpeedModule::stopDriveOffCalibration(); }

void SaveGPSCalibration(lv_event_t *e) { SpeedModule::applyGPSCalibration(); }

void CalculateCalibrationCalculatorNumberButton(lv_event_t *e) {
  int teeth = atoi(lv_textarea_get_text(ui_SettingsTextareaCalibrationCalculatorNumTeethTextArea));
  float diameter = atof(lv_textarea_get_text(ui_SettingsTextareaCalibrationCalculatorWheelDiameterTextArea));
  float ratio = atof(lv_textarea_get_text(ui_SettingsTextareaCalibrationCalculatorGearRatioTextArea));
  int result = SpeedModule::calculateCalibrationFromInputs(teeth, diameter, ratio);
  lv_label_set_text_fmt(ui_SettingsLabelGearToothCalculatorPulses, "%d", result);
}

void RecalibrateTouch(lv_event_t *e) { TouchScreen::setRecalibrationFlag(); }

void HELPTachAutoConnect(lv_event_t *e) {
  // Your code here
}

void HELPAlarmPresets(lv_event_t *e) {
  static const char *btn_txts[] = {"OK", NULL};

  const char *help_text =
      "Each preset defines a full set of alarm thresholds used during the pull.\n\n"
      "There are 4 presets available. You can switch between them using the dropdown menu.\n\n"
      "Each preset contains up to 6 alarms:\n"
      "• 2 Distance alarms\n"
      "• 2 Speed alarms\n"
      "• 2 RPM alarms\n\n"
      "Alarms must be configured with a value and a behavior. The value is the point "
      "where the system considers the alarm to be tripped (e.g., 300 ft or 30 MPH).\n\n"
      "Each alarm also has behavior options, such as:\n"
      "• Silent: no horn or warning, but can still activate relays\n"
      "• Trip once: activates only once when the threshold is crossed\n"
      "• Trip and hold (auto reset): stays on until value goes back below threshold\n"
      "• Trip and hold (persistent): stays on even if value drops below\n"
      "• Auto End Run: immediately ends the pull and sends stop signals to all devices\n\n"
      "Use the activation toggle to enable or disable each individual alarm within the preset.";

  lv_obj_t *mbox = lv_msgbox_create(NULL, "ALARM PRESETS", help_text, btn_txts, true);
  lv_obj_set_width(mbox, 700);
  lv_obj_center(mbox);
  lv_obj_add_event_cb(mbox, CloseMsgBoxEventHandler, LV_EVENT_VALUE_CHANGED, NULL);
}

void CreateDeviceTable(lv_event_t *e) {
  // lv_obj_clean(ui_SettingsPanelDeviceTable);  // Clear old content

  // // Scrollable panel setup
  // lv_obj_set_scroll_dir(ui_SettingsPanelDeviceTable, LV_DIR_VER);
  // lv_obj_set_scrollbar_mode(ui_SettingsPanelDeviceTable, LV_SCROLLBAR_MODE_AUTO);

  // // Table container
  // lv_obj_t *table_container = lv_obj_create(ui_SettingsPanelDeviceTable);
  // lv_obj_set_size(table_container, lv_pct(100), LV_SIZE_CONTENT);
  // lv_obj_set_flex_flow(table_container, LV_FLEX_FLOW_COLUMN);
  // lv_obj_set_scroll_dir(table_container, LV_DIR_VER);
  // lv_obj_set_style_pad_row(table_container, 6, 0);
  // lv_obj_set_style_pad_column(table_container, 4, 0);
  // lv_obj_set_style_border_width(table_container, 0, 0);
  // lv_obj_set_style_bg_opa(table_container, LV_OPA_TRANSP, 0);

  // // Header row
  // lv_obj_t *header = lv_obj_create(table_container);
  // lv_obj_set_width(header, lv_pct(100));
  // lv_obj_set_height(header, LV_SIZE_CONTENT);
  // lv_obj_set_flex_flow(header, LV_FLEX_FLOW_ROW);
  // lv_obj_set_flex_align(header, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
  // lv_obj_set_style_pad_all(header, 4, 0);
  // lv_obj_set_style_pad_column(header, 6, 0);
  // lv_obj_set_style_bg_color(header, lv_palette_lighten(LV_PALETTE_GREY, 3), 0);
  // lv_obj_set_style_border_width(header, 0, 0);
  // lv_obj_clear_flag(header, LV_OBJ_FLAG_SCROLLABLE);

  // auto add_header_label = [&](const char *text, lv_coord_t width) {
  //   lv_obj_t *label = lv_label_create(header);
  //   lv_label_set_text(label, text);
  //   lv_obj_set_width(label, width);
  // };

  // add_header_label("Type", 120);
  // add_header_label("Name", 130);
  // add_header_label("MAC Address", 140);
  // add_header_label("Status", 50);
  // add_header_label("Action", 70);
  // add_header_label("Show Max", 70);

  // // Device struct
  // struct Device {
  //   const char *type;
  //   const char *name;
  //   const char *mac;
  //   bool connected;
  // };

  // std::vector<Device> devices = {{"Distance Display", "Finish Line Display", "AA:BB:CC:DD:EE:01", true},
  //                                {"Safety Light", "Track Light A", "AA:BB:CC:DD:EE:02", false},
  //                                {"Speed Display", "Mid Track Display", "AA:BB:CC:DD:EE:03", false},
  //                                {"Safety Light", "Track Light B", "AA:BB:CC:DD:EE:04", true}};

  // std::sort(devices.begin(), devices.end(), [](const Device &a, const Device &b) { return b.connected < a.connected;
  // });

  // for (const auto &device : devices) {
  //   lv_obj_t *row = lv_obj_create(table_container);
  //   lv_obj_set_width(row, lv_pct(100));
  //   lv_obj_set_height(row, LV_SIZE_CONTENT);
  //   lv_obj_set_flex_flow(row, LV_FLEX_FLOW_ROW);
  //   lv_obj_set_flex_align(row, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
  //   lv_obj_set_style_pad_all(row, 4, 0);
  //   lv_obj_set_style_pad_column(row, 4, 0);
  //   lv_obj_set_style_border_width(row, 0, 0);
  //   lv_obj_set_style_bg_opa(row, LV_OPA_TRANSP, 0);
  //   lv_obj_clear_flag(row, LV_OBJ_FLAG_SCROLLABLE);

  //   // Type
  //   lv_obj_t *type_label = lv_label_create(row);
  //   lv_label_set_text_fmt(type_label, "%s", device.type);
  //   lv_obj_set_width(type_label, 120);

  //   // Name
  //   lv_obj_t *name_label = lv_label_create(row);
  //   lv_label_set_text_fmt(name_label, "%s", device.name);
  //   lv_obj_set_width(name_label, 130);

  //   // MAC
  //   lv_obj_t *mac_label = lv_label_create(row);
  //   lv_label_set_text_fmt(mac_label, "%s", device.mac);
  //   lv_obj_set_width(mac_label, 140);

  //   // Status icon
  //   lv_obj_t *status_icon = lv_label_create(row);
  //   lv_obj_set_width(status_icon, 50);
  //   if (device.connected) {
  //     lv_label_set_text(status_icon, LV_SYMBOL_WIFI);
  //     lv_obj_set_style_text_color(status_icon, lv_color_hex(0x1FA709), 0);
  //   } else {
  //     lv_label_set_text(status_icon, "");
  //   }

  //   // Action button
  //   lv_obj_t *btn = lv_btn_create(row);
  //   lv_obj_set_width(btn, 70);
  //   lv_obj_set_height(btn, 36);
  //   lv_obj_set_style_radius(btn, 5, 0);
  //   lv_obj_set_style_bg_color(btn, lv_color_hex(0xF06B00), 0);
  //   lv_obj_set_flex_flow(btn, LV_FLEX_FLOW_ROW);
  //   lv_obj_set_flex_align(btn, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);

  //   lv_obj_t *btn_label = lv_label_create(btn);
  //   lv_label_set_text(btn_label, device.connected ? "Unpair" : "Pair");

  //   // Show Max toggle
  //   lv_obj_t *toggle = lv_switch_create(row);
  //   lv_obj_set_width(toggle, 50);
  //   lv_obj_add_state(toggle, LV_STATE_CHECKED);
  //   lv_obj_set_style_bg_color(toggle, lv_color_hex(0xF06B00), LV_PART_INDICATOR | LV_STATE_CHECKED);
  //   lv_obj_set_style_bg_color(toggle, lv_palette_main(LV_PALETTE_GREY), LV_PART_INDICATOR);
  //   lv_obj_set_style_radius(toggle, LV_RADIUS_CIRCLE, 0);
  //   lv_obj_set_style_pad_all(toggle, 0, 0);
  // }
}

void DriverButton(lv_event_t *e) {
  StateManager::prefs().pullingClassName = "M4 Sled Monitor - " + String(VERSION);
  StateManager::prefs().pullingClassWeight = 0;
  StateManager::prefs().driverName = "Driver";
  StateManager::prefs().driverNumber += 1;

  StateManager::savePreferences();
}
